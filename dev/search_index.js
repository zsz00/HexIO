var documenterSearchIndex = {"docs":
[{"location":"apis/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"apis/#HexIO-API","page":"API","title":"HexIO API","text":"","category":"section"},{"location":"apis/","page":"API","title":"API","text":"HexIO.unpack\nHexIO.pack\nHexIO.fix_endian\nHexIO.packed_sizeof\nHexIO.@io\n\nHexIO.Hex\nHexIO.dump!\nHexIO.edit!\nHexIO.find!\n","category":"page"},{"location":"apis/#HexIO.unpack","page":"API","title":"HexIO.unpack","text":"unpack(io::IO, T::Type, endianness::Symbol = :NativeEndian)\n\nGiven an input io, unpack type T, byte-swapping according to the given endianness of io. If endianness is :NativeEndian (the default), no byteswapping will occur.  If endianness is :LittleEndian or :BigEndian, byteswapping will occur of the endianness if the host system does not match the endianness of io.\n\n\n\n\n\n","category":"function"},{"location":"apis/#HexIO.pack","page":"API","title":"HexIO.pack","text":"pack(io::IO, source, endianness::Symbol = :NativeEndian)\n\nGiven an input source, pack it into io, byte-swapping according to the given endianness of io. If endianness is :NativeEndian (the default), no byteswapping will occur.  If endianness is :LittleEndian or :BigEndian, byteswapping will occur if the endianness of the host system does not match the endianness of io.\n\n\n\n\n\n","category":"function"},{"location":"apis/#HexIO.fix_endian","page":"API","title":"HexIO.fix_endian","text":"fix_endian(x, endianness::Symbol)\n\nReturns a byte-swapped version of x if the given endianness must be swapped for the current host system.\n\n\n\n\n\n","category":"function"},{"location":"apis/#HexIO.@io","page":"API","title":"HexIO.@io","text":"@io <type definition>\n    ...\nend\n\nGenerates packing_strategy() and packed_sizeof() methods for the type being defined within the given type definition.  This enables usage of the unpack method.\n\n\n\n\n\n","category":"macro"},{"location":"apis/#HexIO.Hex","page":"API","title":"HexIO.Hex","text":"Hex(filename::AbstractString)\n\n\n\n\n\nHex(io::IO)\n\n\n\n\n\n","category":"type"},{"location":"apis/#HexIO.dump!","page":"API","title":"HexIO.dump!","text":"dump!(s::Hex, start=nothing, n=nothing)\n\ndisplay data chunk of n size beginning at offset\n\n\n\n\n\n","category":"function"},{"location":"apis/#HexIO.edit!","page":"API","title":"HexIO.edit!","text":"edit!(s::Hex, datastr::AbstractString, start=nothing)\n\nedit binary file.\n\n\n\n\n\n","category":"function"},{"location":"apis/#HexIO.find!","page":"API","title":"HexIO.find!","text":"find!(s::Hex, sigstr::AbstractString, start=nothing)\n\nsearch for binary signature and return the offset or nothing;  modify s._offset to point to beginning of located signature\n\n\n\n\n\n","category":"function"},{"location":"#HexIO","page":"Introduction","title":"HexIO","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Build Status) (Image: Coverage)","category":"page"},{"location":"#unpack-and-pack","page":"Introduction","title":"unpack and pack","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Generates IO methods (pack, unpack) from structure definitions.  Also defines packed_sizeof to give the on-disk size of a packed structure, which is smaller than sizeof would give, if the struct is marked as align_packed.","category":"page"},{"location":"#Example-usage","page":"Introduction","title":"Example usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using HexIO\n\njulia> @io struct TwoUInt64s\n           x::UInt64\n           y::UInt64\n       end\n\njulia> buf = IOBuffer(collect(UInt8(1):UInt8(16))); \n\njulia> seekstart(buf); unpack(buf, TwoUInt64s) # Default endianness depends on machine\nTwoUInt64s(0x0807060504030201, 0x100f0e0d0c0b0a09)\n\njulia> seekstart(buf); unpack(buf, TwoUInt64s, :BigEndian)\nTwoUInt64s(0x0102030405060708, 0x090a0b0c0d0e0f10)\n\nio = open(\"\", \"rb\")\nbuffer = read(io, read_size)\n","category":"page"},{"location":"#editing-and-displaying","page":"Introduction","title":"editing and displaying","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Hex has same fuctions for editing and displaying data in binary files in hexadecimal format.","category":"page"},{"location":"#dump!(self::Hex,-offset-0,-n::Int-1)","page":"Introduction","title":"dump!(self::Hex, offset = 0, n::Int = -1)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Displays binary file data beginning at offset and ending at offset + n.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"offset defaults to 0\nn defaults to file size - n.","category":"page"},{"location":"#edit!(self::Hex,-datastr::String,-offset-0)","page":"Introduction","title":"edit!(self::Hex, datastr::String, offset = 0)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Edits targeted binary file by overwriting data beginning at offset.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"offset defaults to 0\ndatastr can be in ASCII or hexadecimal format (ie. \"foobar\" or \"0x666f6f626172\")","category":"page"},{"location":"#Example-usage-2","page":"Introduction","title":"Example usage","text":"","category":"section"},{"location":"#Complete-File-Hexdump","page":"Introduction","title":"Complete File Hexdump","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"hex = Hex(\"test/test.bin\")\ndump!(hex, 0x00)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"00000000 | 5D 00 00 80 66 6F 6F 62   61 72 FF FF FF 00 7F E1 |]...foobar......\n00000010 | 90 E6 67 83 93 40 93 22   A0 1B AB 50 6E A1 93 54 |..g..@.\"...Pn..T\n00000020 | 3A 7F FD A3 D9 C0 60 29   AF B6 94 96 3E AA 5C 38 |:.....`)....>.\\8\n00000030 | 1C 05 02 31 7D 74 72 0D   40 3C 22 DA EF FA CA 80 |...1}tr.@<\".....\n00000040 | DF F8 E2 7B CC 65 09 29   64 C3 15 DE E6 39 B7 7E |...{.e.)d....9.~\n00000050 | D5 8C AA 91 F0 28 37 E1   5D AD C0 37 74 16 CE C1 |.....(7.]..7t...\n00000060 | 75 94 1E EA DD 64 D6 B5   A1 2E 54 3D 62 4B 72 30 |u....d....T=bKr0\n00000070 | 5A 35 B8 5D 42 A2 24 A1   C6 22 6A BE C6 58 07 E5 |Z5.]B.$..\"j..X..\n00000080 | 4F F1 E3 FC 53 14 70 AA   AE 58 FA E3 D8 C4 3A DB |O...S.p..X....:.\n00000090 | D2 81 CF 99 24 10 4C C1   53 76 98 BC 16 E9 C2 7E |....$.L.Sv.....~\n000000A0 | 2C 6F 23 D6 F7 32 AB 81   7E 74 FD B6 FE B2 E7 15 |,o#..2..~t......\n000000B0 | 83 7D 45 96 44 A8 D9 CF   B2 B8 AD 37 73 0E 15 AD |.}E.D......7s...\nand so on...","category":"page"},{"location":"#Chunk-Hexdump","page":"Introduction","title":"Chunk Hexdump","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Dump 16 bytes beginning at offset 0x04","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hex = Hex(\"test.bin\")\ndump!(hex, 0x04, 16)\n\n00000004 | 66 6F 6F 62 61 72 FF FF   FF 00 7F E1 90 E6 67 83 |foobar........g.\n\ndump!(hex.hex, 0x04, 16)\n\n00000004 | 66 6F 6F 62 61 72 FF FF   FF 00 7F E1 90 E6 67 83 |foobar........g.","category":"page"},{"location":"#Hexadecimal-Editing-(Hex-String)","page":"Introduction","title":"Hexadecimal Editing (Hex String)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Write foobar to test.bin beginning at offset 0x04","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hex = Hex(\"test.bin\")\nedit!(hex, \"0x666f6f626172\", 0x04)","category":"page"},{"location":"#Hexadecimal-Editing-(ASCII-string)","page":"Introduction","title":"Hexadecimal Editing (ASCII string)","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Write foobar to test.bin beginning at offset 0x04","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hex = Hex(\"test.bin\")\nedit!(hex, \"foobar\", 0x04)","category":"page"},{"location":"#Binary-Singature-Location","page":"Introduction","title":"Binary Singature Location","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Return offset of the start of the hexadecimal signature \"b77e\"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"hex = Hex(\"test.bin\")\noffset = find!(hex, \"0xb77e\")","category":"page"},{"location":"example/#HexIO-Example","page":"Example","title":"HexIO Example","text":"","category":"section"},{"location":"example/#Example-usage","page":"Example","title":"Example usage","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"julia> using HexIO\n\njulia> @io struct TwoUInt64s\n           x::UInt64\n           y::UInt64\n       end\n\njulia> buf = IOBuffer(collect(UInt8(1):UInt8(16))); \n\njulia> seekstart(buf); unpack(buf, TwoUInt64s) # Default endianness depends on machine\nTwoUInt64s(0x0807060504030201, 0x100f0e0d0c0b0a09)\n\njulia> seekstart(buf); unpack(buf, TwoUInt64s, :BigEndian)\nTwoUInt64s(0x0102030405060708, 0x090a0b0c0d0e0f10)\n\nio = open(\"\", \"rb\")\nbuffer = read(io, read_size)\n","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"Hex has same fuctions for editing and displaying data in binary files in hexadecimal format.","category":"page"},{"location":"example/#Synopsis","page":"Example","title":"Synopsis","text":"","category":"section"},{"location":"example/#dump!(self::Hex,-offset-0,-n::Int-1)","page":"Example","title":"dump!(self::Hex, offset = 0, n::Int = -1)","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Displays binary file data beginning at offset and ending at offset + n.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"offset defaults to 0\nn defaults to file size - n.","category":"page"},{"location":"example/#edit!(self::Hex,-datastr::String,-offset-0)","page":"Example","title":"edit!(self::Hex, datastr::String, offset = 0)","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Edits targeted binary file by overwriting data beginning at offset.","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"offset defaults to 0\ndatastr can be in ASCII or hexadecimal format (ie. \"foobar\" or \"0x666f6f626172\")","category":"page"},{"location":"example/#Examples","page":"Example","title":"Examples","text":"","category":"section"},{"location":"example/#Complete-File-Hexdump","page":"Example","title":"Complete File Hexdump","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"hex = Hex(\"test/test.bin\")\ndump!(hex, 0x00)","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"00000000 | 5D 00 00 80 66 6F 6F 62   61 72 FF FF FF 00 7F E1 |]...foobar......\n00000010 | 90 E6 67 83 93 40 93 22   A0 1B AB 50 6E A1 93 54 |..g..@.\"...Pn..T\n00000020 | 3A 7F FD A3 D9 C0 60 29   AF B6 94 96 3E AA 5C 38 |:.....`)....>.\\8\n00000030 | 1C 05 02 31 7D 74 72 0D   40 3C 22 DA EF FA CA 80 |...1}tr.@<\".....\n00000040 | DF F8 E2 7B CC 65 09 29   64 C3 15 DE E6 39 B7 7E |...{.e.)d....9.~\n00000050 | D5 8C AA 91 F0 28 37 E1   5D AD C0 37 74 16 CE C1 |.....(7.]..7t...\n00000060 | 75 94 1E EA DD 64 D6 B5   A1 2E 54 3D 62 4B 72 30 |u....d....T=bKr0\n00000070 | 5A 35 B8 5D 42 A2 24 A1   C6 22 6A BE C6 58 07 E5 |Z5.]B.$..\"j..X..\n00000080 | 4F F1 E3 FC 53 14 70 AA   AE 58 FA E3 D8 C4 3A DB |O...S.p..X....:.\n00000090 | D2 81 CF 99 24 10 4C C1   53 76 98 BC 16 E9 C2 7E |....$.L.Sv.....~\n000000A0 | 2C 6F 23 D6 F7 32 AB 81   7E 74 FD B6 FE B2 E7 15 |,o#..2..~t......\n000000B0 | 83 7D 45 96 44 A8 D9 CF   B2 B8 AD 37 73 0E 15 AD |.}E.D......7s...\nand so on...","category":"page"},{"location":"example/#Chunk-Hexdump","page":"Example","title":"Chunk Hexdump","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Dump 16 bytes beginning at offset 0x04","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"hex = Hex(\"test.bin\")\ndump!(hex, 0x04, 16)\n\n00000004 | 66 6F 6F 62 61 72 FF FF   FF 00 7F E1 90 E6 67 83 |foobar........g.\n\ndump!(hex.hex, 0x04, 16)\n\n00000004 | 66 6F 6F 62 61 72 FF FF   FF 00 7F E1 90 E6 67 83 |foobar........g.","category":"page"},{"location":"example/#Hexadecimal-Editing-(Hex-String)","page":"Example","title":"Hexadecimal Editing (Hex String)","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Write foobar to test.bin beginning at offset 0x04","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"hex = Hex(\"test.bin\")\nedit!(hex, \"0x666f6f626172\", 0x04)","category":"page"},{"location":"example/#Hexadecimal-Editing-(ASCII-string)","page":"Example","title":"Hexadecimal Editing (ASCII string)","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Write foobar to test.bin beginning at offset 0x04","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"hex = Hex(\"test.bin\")\nedit!(hex, \"foobar\", 0x04)","category":"page"},{"location":"example/#Binary-Singature-Location","page":"Example","title":"Binary Singature Location","text":"","category":"section"},{"location":"example/","page":"Example","title":"Example","text":"Return offset of the start of the hexadecimal signature \"b77e\"","category":"page"},{"location":"example/","page":"Example","title":"Example","text":"hex = Hex(\"test.bin\")\noffset = find!(hex, \"0xb77e\")","category":"page"}]
}
